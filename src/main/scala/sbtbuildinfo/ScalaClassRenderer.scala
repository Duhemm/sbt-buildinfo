package sbtbuildinfo

private[sbtbuildinfo] case class ScalaClassRenderer(options: Seq[BuildInfoOption], pkg: String, obj: String) extends BuildInfoRenderer {

  override def fileType = BuildInfoType.Source
  override def extension = "scala"

  override def header = List(
  s"package $pkg",
  "",
  "import java.io.File",
  "import java.net.URL",
  "",
  s"/** This object was generated by sbt-buildinfo. */",
  s"case object $obj {")

  override def footer = List("}")

  override def renderKeys(buildInfoResults: Seq[BuildInfoResult]) =
    buildInfoResults.flatMap(line) ++ Seq(toStringLine(buildInfoResults)) ++
    toMapLine(buildInfoResults) ++ toJsonLine

  private def line(result: BuildInfoResult): Seq[String] = {
    import result._
    val typeDecl = getType(result.typeExpr) map { ": " + _ } getOrElse ""

    List(
      s"  /** The value is ${quote(value)}. */",
      s"  val $identifier$typeDecl = ${quote(value)}"
    )
  }

  def toStringLine(results: Seq[BuildInfoResult]): String = {
    val idents = results.map(_.identifier)
    val fmt = idents.map("%s: %%s" format _).mkString(", ")
    val vars = idents.mkString(", ")
    s"""  override val toString: String = "$fmt" format ($vars)"""
  }

  def toMapLine(results: Seq[BuildInfoResult]): Seq[String] =
    if (options.contains(BuildInfoOption.ToMap) || options.contains(BuildInfoOption.ToJson))
      results
        .map(result => "    \"%s\" -> %s".format(result.identifier, result.identifier))
        .mkString("  val toMap: Map[String, Any] = Map[String, Any](\n", ",\n", ")")
        .split("\n")
        .toList ::: List("")
    else Nil

  def toJsonLine: Seq[String] =
    if (options contains BuildInfoOption.ToJson)
      List("""  val toJson: String = toMap.map(i => "\"" + i._1 + "\":\"" + i._2 + "\"").mkString("{", ", ", "}")""")
    else Nil

  private def getType(typeExpr: TypeExpression): Option[String] = {
    def tpeToReturnType(tpe: TypeExpression): Option[String] =
      tpe match {
        case TypeExpression("Any", Nil)    => None
        case TypeExpression("Int", Nil)    => Some("Int")
        case TypeExpression("Long", Nil)   => Some("Long")
        case TypeExpression("Double", Nil) => Some("Double")
        case TypeExpression("Boolean", Nil) => Some("Boolean")
        case TypeExpression("scala.Symbol", Nil) => Some("scala.Symbol")
        case TypeExpression("java.lang.String", Nil) => Some("String")
        case TypeExpression("java.net.URL", Nil) => Some("URL")
        case TypeExpression("sbt.URL", Nil) => Some("URL")
        case TypeExpression("java.io.File", Nil) => Some("File")
        case TypeExpression("sbt.File", Nil) => Some("File")
        case TypeExpression("scala.xml.NodeSeq", Nil) => Some("scala.xml.NodeSeq")

        case TypeExpression("sbt.ModuleID", Nil) => Some("String")
        case TypeExpression("sbt.Resolver", Nil) => Some("String")

        case TypeExpression("scala.Option", Seq(arg)) =>
          tpeToReturnType(arg) map { x => s"Option[$x]" }
        case TypeExpression("scala.collection.Seq", Seq(arg)) =>
          tpeToReturnType(arg) map { x => s"Seq[$x]" }
        case TypeExpression("scala.collection.immutable.Map", Seq(arg0, arg1)) =>
          for {
            x0 <- tpeToReturnType(arg0)
            x1 <- tpeToReturnType(arg1)
          } yield s"Map[$x0, $x1]"
        case TypeExpression("scala.Tuple2", Seq(arg0, arg1)) =>
          for {
            x0 <- tpeToReturnType(arg0)
            x1 <- tpeToReturnType(arg1)
          } yield s"($x0, $x1)"
        case _ => None
      }
    tpeToReturnType(typeExpr)
  }

  private def quote(v: Any): String = v match {
    case x @ ( _: Int | _: Double | _: Boolean | _: Symbol) => x.toString
    case x: Long            => x.toString + "L"
    case node: scala.xml.NodeSeq if node.toString().trim.nonEmpty => node.toString()
    case (k, _v)            => "(%s -> %s)" format(quote(k), quote(_v))
    case mp: Map[_, _]      => mp.toList.map(quote(_)).mkString("Map(", ", ", ")")
    case seq: Seq[_]        => seq.map(quote).mkString("Seq(", ", ", ")")
    case op: Option[_]      => op map { x => "Some(" + quote(x) + ")" } getOrElse {"None"}
    case url: java.net.URL  => "new URL(%s)" format quote(url.toString)
    case file: java.io.File => "new File(%s)" format quote(file.toString)
    case s                  => "\"%s\"" format encodeStringLiteral(s.toString)
  }

  def encodeStringLiteral(str: String): String =
    str.replace("\\","\\\\").replace("\n","\\n").replace("\b","\\b").replace("\r","\\r").
      replace("\t","\\t").replace("\'","\\'").replace("\f","\\f").replace("\"","\\\"")
}
