package sbtbuildinfo

import sbt._, Keys._

object BuildInfo {
  def apply(dir: File, obj: String, pkg: String, keys: Seq[BuildInfoKey],
      proj: ProjectRef, state: State, cacheDir: File): File =
    BuildInfoTask(dir, obj, pkg, keys, proj, state, cacheDir).file

  private case class BuildInfoTask(dir: File, obj: String, pkg: String, keys: Seq[BuildInfoKey],
      proj: ProjectRef, state: State, cacheDir: File) {
    import FileInfo.hash
    import Tracked.inputChanged

    def extracted = Project.extract(state)
    val tempFile = cacheDir / "sbtbuildinfo" / s"""$obj.scala"""
    val outFile = dir / (s"""$obj.scala""")

    // 1. make the file under cache/sbtbuildinfo.
    // 2. compare its SHA1 against cache/sbtbuildinfo-inputs
    def file: File = {
      makeFile(tempFile)
      cachedCopyFile { hash(tempFile) }
      outFile
    }

    val cachedCopyFile =
      inputChanged(cacheDir / "sbtbuildinfo-inputs") { (inChanged, input: HashFileInfo) =>
        if (inChanged || !outFile.exists) {
          IO.copyFile(tempFile, outFile, true)
        } // if
      }

    def makeFile(file: File): File = {
      val distinctKeys = keys.toList.distinct
      val lines =
        List(s"""package $pkg""",
          "",
          s"""/** This object was generated by sbt-buildinfo. */""",
          s"""case object $obj {""") :::
        (distinctKeys flatMap { line(_) }) :::
        List(toStringLine(distinctKeys), "") :::
        makeToMapMethod(distinctKeys) ::: List("") ::: 
        List(toJsonLine()) ::: List("}")
      IO.write(file, lines.mkString("\n"))
      file
    }

    def line(info: BuildInfoKey): List[String] =
      entry(info) match {
        case Some((ident, value)) =>
          val typeDecl: String = getType(info) map { ": " + _ } getOrElse ""
          List(s"""  /** The value is ${quote(value)}. */""",
            s"""  val $ident$typeDecl = ${quote(value)}""")
        case _ => Nil
      }

    def toStringLine(keys: Seq[BuildInfoKey]): String = {
      val idents = keys.map(entry(_)).flatten.map(_._1)
      val fmt = idents.map("%s: %%s" format _).mkString(", ")
      val vars = idents.mkString(", ")
      s"""  override val toString = "$fmt" format ($vars)"""
    }

    def toJsonLine(): String = {
      """  val toJson = toMap.map(i => "\""+i._1+"\":\""+i._2+"\"").mkString("{",", ","}")"""
    }

    def makeToMapMethod(distinctKeys: List[BuildInfoKey]): List[String] =
      distinctKeys.map { key => entry(key) }.flatten.map {
        case (ident, _) => "    \"%s\" -> %s".format(ident, ident)
      }.mkString("  val toMap: Map[String, Any] = Map[String, Any](\n", ",\n", ")").split("\n").toList

    def entry[A](info: BuildInfoKey.Entry[A]): Option[(String, A)] = info match {
      case BuildInfoKey.Setting(key)      => extracted getOpt (key in scope(key)) map { ident(key) -> _ }
      case BuildInfoKey.Task(key)         => Some(ident(key) -> extracted.runTask(key in scope(key), state)._2)
      case BuildInfoKey.Constant(tuple)   => Some(tuple)
      case BuildInfoKey.Action(name, fun) => Some(name -> fun.apply)
      case BuildInfoKey.Mapped(from, fun) => entry(from) map fun
    }

    def scope(scoped: Scoped) = {
      val scope0 = scoped.scope
      if (scope0.project == This) scope0 in (proj)
      else scope0
    }

    def ident(scoped: Scoped) : String = {
      val scope = scoped.scope
      (scope.config.toOption match {
        case None => ""
        case Some(ConfigKey("compile")) => ""
        case Some(ConfigKey(x)) => x + "_"
      }) +
      (scope.task.toOption match {
        case None => ""
        case Some(x) => x.label + "_"
      }) +
      (scoped.key.label.split("-").toList match {
        case Nil => ""
        case x :: xs => x + (xs map {_.capitalize}).mkString("")
      })
    }

    def getType(info: BuildInfoKey): Option[String] = {
      val mf = info.manifest
      if(mf.runtimeClass == classOf[Option[_]]) {
        val s = mf.toString
        Some(if( s.startsWith("scala.")) s.substring(6) else s)
      } else None
    }

    def quote(v: Any): String = v match {
      case x @ ( _: Int | _: Double | _: Boolean | _: Symbol) => x.toString
      case x: Long            => x.toString + "L"
      case node: scala.xml.NodeSeq if node.toString.trim.nonEmpty => node.toString
      case (k, _v)            => "(%s -> %s)" format(quote(k), quote(_v))
      case mp: Map[_, _]      => mp.toList.map(quote(_)).mkString("Map(", ", ", ")")
      case seq: Seq[_]        => seq.map(quote(_)).mkString("Seq(", ", ", ")")
      case op: Option[_]      => op map { x => "Some(" + quote(x) + ")" } getOrElse {"None"}
      case url: java.net.URL  => "new java.net.URL(%s)" format quote(url.toString)
      case file: java.io.File => "new java.io.File(%s)" format quote(file.toString)
      case s                  => "\"%s\"" format encodeStringLiteral(s.toString)
    }

    def encodeStringLiteral(str: String): String =
      str.replace("\\","\\\\").replace("\n","\\n").replace("\b","\\b").replace("\r","\\r").
        replace("\t","\\t").replace("\'","\\'").replace("\f","\\f").replace("\"","\\\"")
  }
}
