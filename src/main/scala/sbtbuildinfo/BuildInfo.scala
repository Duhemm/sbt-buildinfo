package sbtbuildinfo

import sbt._, Keys._

object BuildInfo {
  def apply(dir: File, obj: String, pkg: String, keys: Seq[BuildInfoKey],
      options: Seq[BuildInfoOption],
      proj: ProjectRef, state: State, cacheDir: File): File =
    BuildInfoTask(dir, obj, pkg, keys, options, proj, state, cacheDir).file

  private case class BuildInfoTask(dir: File, obj: String, pkg: String,
      keys: Seq[BuildInfoKey], options: Seq[BuildInfoOption],
      proj: ProjectRef, state: State, cacheDir: File) {
    import FileInfo.hash
    import Tracked.inputChanged

    def extracted = Project.extract(state)
    val tempFile = cacheDir / "sbtbuildinfo" / s"""$obj.scala"""
    val outFile = dir / (s"""$obj.scala""")

    // 1. make the file under cache/sbtbuildinfo.
    // 2. compare its SHA1 against cache/sbtbuildinfo-inputs
    def file: File = {
      makeFile(tempFile)
      cachedCopyFile { hash(tempFile) }
      outFile
    }

    val cachedCopyFile =
      inputChanged(cacheDir / "sbtbuildinfo-inputs") { (inChanged, input: HashFileInfo) =>
        if (inChanged || !outFile.exists) {
          IO.copyFile(tempFile, outFile, true)
        } // if
      }

    def makeFile(file: File): File = {
      val distinctKeys = keys.toList.distinct
      val lines =
        List(s"""package $pkg""",
          "",
          "import java.io.File",
          "import java.net.URL",
          "",
          s"""/** This object was generated by sbt-buildinfo. */""",
          s"""case object $obj {""") :::
        (distinctKeys flatMap { line(_) }) :::
        List(toStringLine(distinctKeys)) :::
        toMapLine(distinctKeys) ::: 
        toJsonLine :::
        List("}")
      IO.write(file, lines.mkString("\n"))
      file
    }

    def line(info: BuildInfoKey): List[String] =
      entry(info) match {
        case Some((ident, value)) =>
          val typeDecl: String = getType(info) map { ": " + _ } getOrElse ""
          List(s"""  /** The value is ${quote(value)}. */""",
            s"""  val $ident$typeDecl = ${quote(value)}""")
        case _ => Nil
      }

    def toStringLine(keys: Seq[BuildInfoKey]): String = {
      val idents = keys.map(entry(_)).flatten.map(_._1)
      val fmt = idents.map("%s: %%s" format _).mkString(", ")
      val vars = idents.mkString(", ")
      s"""  override val toString: String = "$fmt" format ($vars)"""
    }

    def toJsonLine: List[String] =
      if (options contains BuildInfoOption.ToJson)
        List("""  val toJson: String = toMap.map(i => "\"" + i._1 + "\":\"" + i._2 + "\"").mkString("{", ", ", "}")""")
      else Nil

    def toMapLine(distinctKeys: List[BuildInfoKey]): List[String] =
      if ((options contains BuildInfoOption.ToMap) || (options contains BuildInfoOption.ToJson))
        (distinctKeys.map { key => entry(key) }.flatten.map {
          case (ident, _) => "    \"%s\" -> %s".format(ident, ident)
        }.mkString("  val toMap: Map[String, Any] = Map[String, Any](\n", ",\n", ")").split("\n").toList) ::: List("")
      else Nil

    def entry[A](info: BuildInfoKey.Entry[A]): Option[(String, A)] = info match {
      case BuildInfoKey.Setting(key)      => extracted getOpt (key in scope(key)) map { ident(key) -> _ }
      case BuildInfoKey.Task(key)         => Some(ident(key) -> extracted.runTask(key in scope(key), state)._2)
      case BuildInfoKey.Constant(tuple)   => Some(tuple)
      case BuildInfoKey.Action(name, fun) => Some(name -> fun.apply)
      case BuildInfoKey.Mapped(from, fun) => entry(from) map fun
    }

    def scope(scoped: Scoped) = {
      val scope0 = scoped.scope
      if (scope0.project == This) scope0 in (proj)
      else scope0
    }

    def ident(scoped: Scoped) : String = {
      val scope = scoped.scope
      (scope.config.toOption match {
        case None => ""
        case Some(ConfigKey("compile")) => ""
        case Some(ConfigKey(x)) => x + "_"
      }) +
      (scope.task.toOption match {
        case None => ""
        case Some(x) => x.label + "_"
      }) +
      (scoped.key.label.split("-").toList match {
        case Nil => ""
        case x :: xs => x + (xs map {_.capitalize}).mkString("")
      })
    }

    def getType(info: BuildInfoKey): Option[String] = {
      val mf = info.manifest
      val (tpe0, rest) = TypeExpression.parse(mf.toString)
      def tpeToReturnType(tpe: TypeExpression): Option[String] =
        tpe match {
          case TypeExpression("Any", Nil)    => None
          case TypeExpression("Int", Nil)    => Some("Int")
          case TypeExpression("Long", Nil)   => Some("Long")
          case TypeExpression("Double", Nil) => Some("Double")
          case TypeExpression("Boolean", Nil) => Some("Boolean")
          case TypeExpression("scala.Symbol", Nil) => Some("scala.Symbol")
          case TypeExpression("java.lang.String", Nil) => Some("String")
          case TypeExpression("java.net.URL", Nil) => Some("URL")
          case TypeExpression("sbt.URL", Nil) => Some("URL")
          case TypeExpression("java.io.File", Nil) => Some("File")
          case TypeExpression("sbt.File", Nil) => Some("File")
          case TypeExpression("scala.xml.NodeSeq", Nil) => Some("scala.xml.NodeSeq")

          case TypeExpression("sbt.ModuleID", Nil) => Some("String")
          case TypeExpression("sbt.Resolver", Nil) => Some("String")

          case TypeExpression("scala.Option", Seq(arg)) =>
            tpeToReturnType(arg) map { x => s"Option[$x]" }
          case TypeExpression("scala.collection.Seq", Seq(arg)) =>
            tpeToReturnType(arg) map { x => s"Seq[$x]" }
          case TypeExpression("scala.collection.immutable.Map", Seq(arg0, arg1)) =>
            for {
              x0 <- tpeToReturnType(arg0)
              x1 <- tpeToReturnType(arg1)
            } yield s"Map[$x0, $x1]"
          case TypeExpression("scala.Tuple2", Seq(arg0, arg1)) =>
            for {
              x0 <- tpeToReturnType(arg0)
              x1 <- tpeToReturnType(arg1)
            } yield s"($x0, $x1)"
          case _ => None
        }
      tpeToReturnType(tpe0)
    }

    def quote(v: Any): String = v match {
      case x @ ( _: Int | _: Double | _: Boolean | _: Symbol) => x.toString
      case x: Long            => x.toString + "L"
      case node: scala.xml.NodeSeq if node.toString.trim.nonEmpty => node.toString
      case (k, _v)            => "(%s -> %s)" format(quote(k), quote(_v))
      case mp: Map[_, _]      => mp.toList.map(quote(_)).mkString("Map(", ", ", ")")
      case seq: Seq[_]        => seq.map(quote(_)).mkString("Seq(", ", ", ")")
      case op: Option[_]      => op map { x => "Some(" + quote(x) + ")" } getOrElse {"None"}
      case url: java.net.URL  => "new URL(%s)" format quote(url.toString)
      case file: java.io.File => "new File(%s)" format quote(file.toString)
      case s                  => "\"%s\"" format encodeStringLiteral(s.toString)
    }

    def encodeStringLiteral(str: String): String =
      str.replace("\\","\\\\").replace("\n","\\n").replace("\b","\\b").replace("\r","\\r").
        replace("\t","\\t").replace("\'","\\'").replace("\f","\\f").replace("\"","\\\"")
  }
}
